{"version":3,"sources":["../node_modules/warning/warning.js","../node_modules/react-compound-slider/node_modules/d3-array/src/ticks.js","../../src/Slider/utils.ts","../../src/Slider/modes.ts","../../src/utils.ts","../../src/Rail/Rail.tsx","../../src/Handles/Handles.tsx","../../src/scales/LinearScale.ts","../../src/Ticks/Ticks.tsx","../../src/Tracks/Tracks.tsx","../../src/scales/DiscreteScale.ts","../../src/Slider/Slider.tsx"],"names":["warning","module","exports","e10","Math","sqrt","e5","e2","start","stop","count","reverse","n","ticks","step","i","max","power","floor","log","LN10","error","pow","tickIncrement","isFinite","r0","round","r1","Array","prfx","getSortByVal","reversed","a","b","getUpdatedHandles","index","handles","v","key","val","updateValue","getSliderDomain","slider","s","vertical","isNotValidTouch","type","touches","getTouchPosition","e","getHandles","values","valueToStep","warn","changes","x","mode1","_","mode2","curr","next","mode3","indexForMovingHandle","handleMoveIsPositive","c","increment","n0","n1","newStep","getValue","check","callAll","fns","fn","NOOP","value","percent","Rail","props","emitMouse","emitTouch","onMouseDown","onTouchStart","getRailProps","getEventData","activeHandleID","renderedChildren","children","React","Handles","emitKeyboard","onKeyDown","getHandleProps","LinearScale","interpolator","domain","range","this","d0","d1","t","createInterpolator","d","defaultGetEventData","Ticks","scale","id","Tracks","getTrackProps","left","right","tracks","source","target","clamp","DiscreteScale","p","isBrowser","window","document","noop","getNextValue","newVal","getPrevValue","defaultDomain","Slider","valueToPerc","pixelToStep","validUpKeys","validDownKeys","found","currVal","nextHandles","isTouch","onChange","onSlideEnd","onSlideStart","handleID","updateKey","minDiff","diff","callOnChange","mode","onUpdate","state","className","rootStyle","rootProps","Comp","disabled","flatten","mappedHandles","item","isValidElement","name","isRCSComponent","style","ref","nextProps","warnOnChanges","prevState","nextState","min","m","compare","Object"],"mappings":"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","file":"static/js/14.c4707a21.chunk.js","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n","var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    let r0 = Math.round(start / step), r1 = Math.round(stop / step);\n    if (r0 * step < start) ++r0;\n    if (r1 * step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) * step;\n  } else {\n    step = -step;\n    let r0 = Math.round(start * step), r1 = Math.round(stop * step);\n    if (r0 / step < start) ++r0;\n    if (r1 / step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n","import React from 'react';\nimport warning from 'warning';\n\nimport { DiscreteScale } from '../scales/DiscreteScale';\nimport { HandleItem } from '../types';\n\nexport const prfx = 'react-compound-slider:';\n\nexport function getSortByVal(reversed: boolean = false) {\n  return function sortByVal(a: HandleItem, b: HandleItem) {\n    if (a.val > b.val) {\n      return reversed ? -1 : 1;\n    }\n\n    if (b.val > a.val) {\n      return reversed ? 1 : -1;\n    }\n\n    return 0;\n  };\n}\n\nexport function getUpdatedHandles(\n  handles: HandleItem[],\n  updateKey: string,\n  updateValue: number,\n  reversed: boolean = false\n) {\n  const index = handles.findIndex(v => v.key === updateKey);\n\n  if (index !== -1) {\n    const { key, val } = handles[index];\n\n    if (val === updateValue) {\n      return handles;\n    }\n\n    return [\n      ...handles.slice(0, index),\n      { key, val: updateValue },\n      ...handles.slice(index + 1),\n    ].sort(getSortByVal(reversed));\n  }\n\n  return handles;\n}\n\nexport function getSliderDomain(slider: Element | null, vertical: boolean) {\n  if (!slider) {\n    return [0, 0];\n  }\n\n  const s = slider.getBoundingClientRect();\n\n  const d0 = vertical ? s.top : s.left;\n  const d1 = vertical ? s.bottom : s.right;\n\n  return [d0, d1];\n}\n\nexport function isNotValidTouch({\n  type = '',\n  touches,\n}: {\n  type: string;\n  touches: TouchEvent['touches'];\n}) {\n  return (\n    !touches ||\n    touches.length > 1 ||\n    (type.toLowerCase() === 'touchend' && touches.length > 0)\n  );\n}\n\nexport function getTouchPosition(\n  vertical: boolean,\n  e: React.TouchEvent | TouchEvent\n) {\n  return vertical ? e.touches[0].clientY : e.touches[0].pageX;\n}\n\nexport function getHandles(\n  values: ReadonlyArray<number> = [],\n  reversed: boolean,\n  valueToStep: DiscreteScale,\n  warn: boolean\n) {\n  let changes = 0;\n\n  const handles = values\n    .map(x => {\n      const val = valueToStep.getValue(x);\n\n      if (x !== val) {\n        changes += 1;\n        warning(\n          !warn,\n          `${prfx} Invalid value encountered. Changing ${x} to ${val}.`\n        );\n      }\n\n      return val;\n    })\n    .map((val, i) => ({ key: `$$-${i}`, val }))\n    .sort(getSortByVal(reversed));\n\n  return { handles, changes };\n}\n","import { getUpdatedHandles } from './utils';\nimport { HandleItem } from '../types';\n\n// default mode\nexport function mode1(_: HandleItem[], next: HandleItem[]) {\n  return next;\n}\n\n// prevent duplicate values and crossing\nexport function mode2(curr: HandleItem[], next: HandleItem[]) {\n  for (let i = 0; i < curr.length; i++) {\n    if (curr[i].key !== next[i].key) {\n      return curr;\n    }\n\n    if (next[i + 1] && next[i].val === next[i + 1].val) {\n      return curr;\n    }\n  }\n\n  return next;\n}\n\n// pushable mode\nexport function mode3(\n  curr: HandleItem[],\n  next: HandleItem[],\n  step: number,\n  reversed: boolean,\n  getValue: (x: number) => number\n): HandleItem[] {\n  let indexForMovingHandle = -1;\n  let handleMoveIsPositive = true;\n\n  for (let i = 0; i < curr.length; i++) {\n    const c = curr[i];\n    const n = next[i];\n\n    // make sure keys are in same order if not return curr\n    if (!n || n.key !== c.key) {\n      return curr;\n    } else if (n.val !== c.val) {\n      indexForMovingHandle = i;\n      handleMoveIsPositive = n.val - c.val > 0;\n    }\n  }\n\n  // nothing has changed (shouldn't happen but just in case).\n  if (indexForMovingHandle === -1) {\n    return curr;\n  } else {\n    const increment = handleMoveIsPositive ? step : -step;\n\n    for (let i = 0; i < next.length; i++) {\n      const n0 = next[i];\n      const n1 = next[i + 1];\n\n      if (n1 && n0.val === n1.val) {\n        if (i === indexForMovingHandle) {\n          const newStep = n1.val + increment;\n          if (getValue(newStep) === newStep) {\n            const clone = getUpdatedHandles(\n              next,\n              n1.key,\n              n1.val + increment,\n              reversed\n            );\n            const check = mode3(next, clone, step, reversed, getValue);\n\n            if (check === next) {\n              return curr;\n            } else {\n              return check;\n            }\n          } else {\n            return curr;\n          }\n        } else {\n          const newStep = n0.val + increment;\n          if (getValue(newStep) === newStep) {\n            const clone = getUpdatedHandles(\n              next,\n              n0.key,\n              n0.val + increment,\n              reversed\n            );\n            const check = mode3(next, clone, step, reversed, getValue);\n\n            if (check === next) {\n              return curr;\n            } else {\n              return check;\n            }\n          } else {\n            return curr;\n          }\n        }\n      }\n    }\n  }\n\n  return next;\n}\n","export function callAll<T>(...fns: (((e: T) => void) | undefined)[]) {\n  return (e: T) => {\n    return fns.forEach(fn => fn && fn(e));\n  };\n}\n","import React, { Component } from 'react';\nimport { callAll } from '../utils';\n\nimport { OtherProps } from '../types';\nimport { RailProps } from './types';\n\nconst NOOP = () => ({ value: 0, percent: 0 });\n\nexport class Rail extends Component<RailProps> {\n  getRailProps = (props: OtherProps = {}) => {\n    const { emitMouse, emitTouch } = this.props;\n\n    return {\n      ...props,\n      onMouseDown: callAll<React.MouseEvent<Element>>(\n        props && props.onMouseDown,\n        emitMouse\n      ),\n      onTouchStart: callAll(props && props.onTouchStart, emitTouch),\n    };\n  };\n\n  render() {\n    const {\n      getRailProps,\n      props: { getEventData, activeHandleID = '', children },\n    } = this;\n\n    const renderedChildren = children({\n      getEventData: getEventData || NOOP,\n      activeHandleID,\n      getRailProps,\n    });\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","import React, { Component } from 'react';\nimport { callAll } from '../utils';\n\nimport { OtherProps } from '../types';\nimport { HandlesProps } from './types';\n\nexport class Handles extends Component<HandlesProps> {\n  autofocus = (e: React.MouseEvent<Element>) => {\n    if (e.target instanceof HTMLElement) {\n      e.target.focus();\n    }\n  };\n\n  getHandleProps = (id: string, props: OtherProps = {}) => {\n    const { emitKeyboard, emitMouse, emitTouch } = this.props;\n\n    return {\n      ...props,\n      onKeyDown: callAll<React.KeyboardEvent<Element>>(\n        props && props.onKeyDown,\n        (e: React.KeyboardEvent<Element>) => emitKeyboard && emitKeyboard(e, id)\n      ),\n      onMouseDown: callAll<React.MouseEvent<Element>>(\n        props && props.onMouseDown,\n        this.autofocus,\n        (e: React.MouseEvent) => emitMouse && emitMouse(e, id)\n      ),\n      onTouchStart: callAll<React.TouchEvent<Element>>(\n        props && props.onTouchStart,\n        (e: React.TouchEvent<Element>) => emitTouch && emitTouch(e, id)\n      ),\n    };\n  };\n\n  render() {\n    const {\n      getHandleProps,\n      props: { activeHandleID = '', children, handles = [] },\n    } = this;\n\n    const renderedChildren = children({\n      handles,\n      activeHandleID,\n      getHandleProps,\n    });\n\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","import { ticks } from 'd3-array';\n\nimport { Interpolator } from '../types';\n\nexport class LinearScale {\n  interpolator: Interpolator | null;\n  domain: number[] = [0, 1];\n  range: number[] = [0, 1];\n\n  constructor() {\n    this.domain = [0, 1];\n    this.range = [0, 1];\n    this.interpolator = null;\n  }\n\n  createInterpolator(domain: number[], range: number[]) {\n    const d0 = domain[0];\n    const d1 = domain[1];\n\n    const r0 = range[0];\n    const r1 = range[1];\n\n    if (d1 < d0) {\n      return (x: number) =>\n        this.interpolateValue(r1, r0)(this.deinterpolateValue(d1, d0)(x));\n    } else {\n      return (x: number) =>\n        this.interpolateValue(r0, r1)(this.deinterpolateValue(d0, d1)(x));\n    }\n  }\n\n  interpolateValue(a: number, b: number) {\n    return (\n      (a = +a),\n      (b -= a),\n      function i(t: number) {\n        return a + b * t;\n      }\n    );\n  }\n\n  deinterpolateValue(a: number, b: number) {\n    return (b -= a = +a) ? (x: number) => (x - a) / b : () => b;\n  }\n\n  rescale() {\n    this.interpolator = null;\n\n    return this;\n  }\n\n  getValue(x: number) {\n    const { domain, range } = this;\n\n    return (\n      this.interpolator ||\n      (this.interpolator = this.createInterpolator(domain, range))\n    )(+x);\n  }\n\n  setDomain(val: number[]) {\n    this.domain = [val[0], val[1]];\n\n    this.rescale();\n\n    return this;\n  }\n\n  getDomain() {\n    return this.domain;\n  }\n\n  setRange(val: number[]) {\n    this.range = [val[0], val[1]];\n\n    return this;\n  }\n\n  getRange() {\n    return this.range;\n  }\n\n  getTicks(count: number) {\n    const d = this.domain;\n    return ticks(d[0], d[d.length - 1], count ? count : 10);\n  }\n}\n","import React, { Component } from 'react';\n\nimport { TicksProps } from './types';\nimport { LinearScale } from '../scales/LinearScale';\n\nconst defaultGetEventData = () => ({ value: 0, percent: 0 });\n\nexport class Ticks extends Component<TicksProps> {\n  public render() {\n    const {\n      children,\n      values,\n      scale = new LinearScale(),\n      count = 10,\n      getEventData = defaultGetEventData,\n      activeHandleID = '',\n    } = this.props;\n\n    const ticks = (values ? values : scale.getTicks(count)).map((value) => ({\n      id: `$$-${value}`,\n      value,\n      percent: scale.getValue(value),\n    }));\n\n    const renderedChildren = children({ getEventData, activeHandleID, ticks });\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","import React, { Component } from 'react';\n\nimport { callAll } from '../utils';\nimport { LinearScale } from '../scales/LinearScale';\nimport { TracksProps } from './types';\nimport { OtherProps } from '../types';\n\nconst defaultGetEventData = () => ({ value: 0, percent: 0 });\n\nexport class Tracks extends Component<TracksProps> {\n  getTrackProps = (props?: OtherProps) => {\n    const { emitMouse, emitTouch } = this.props;\n\n    return {\n      ...(props || {}),\n      onMouseDown: callAll<React.MouseEvent<Element>>(\n        props && props.onMouseDown,\n        emitMouse\n      ),\n      onTouchStart: callAll<React.TouchEvent<Element>>(\n        props && props.onTouchStart,\n        emitTouch\n      ),\n    };\n  };\n\n  render() {\n    const {\n      getTrackProps,\n      props: {\n        children,\n        left = true,\n        right = true,\n        scale = new LinearScale(),\n        handles = [],\n        getEventData = defaultGetEventData,\n        activeHandleID = '',\n      },\n    } = this;\n\n    const domain = scale.getDomain();\n    const tracks = [];\n\n    for (let i = 0; i < handles.length + 1; i++) {\n      let source = handles[i - 1];\n      let target = handles[i];\n\n      if (i === 0 && left === true) {\n        source = { id: '$', value: domain[0], percent: 0 };\n      } else if (i === handles.length && right === true) {\n        target = { id: '$', value: domain[1], percent: 100 };\n      }\n\n      if (source && target) {\n        tracks.push({\n          id: `${source.id}-${target.id}`,\n          source,\n          target,\n        });\n      }\n    }\n\n    const renderedChildren = children({\n      getEventData,\n      activeHandleID,\n      tracks,\n      getTrackProps,\n    });\n\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport class DiscreteScale {\n  step: number = 1;\n  domain: number[] = [0, 1];\n  range: number[] = [0, 1];\n\n  setDomain = (val: number[]) => {\n    this.domain = [val[0], val[1]];\n\n    return this;\n  };\n\n  setRange = (val: number[]) => {\n    this.range = [val[0], val[1]];\n\n    return this;\n  };\n\n  setStep = (val: number) => {\n    this.step = val;\n\n    return this;\n  };\n\n  getValue = (x: number) => {\n    const {\n      domain: [d0, d1],\n      range: [r0, r1],\n      step,\n    } = this;\n\n    const p = (clamp(x, d0, d1) - d0) / (d1 - d0);\n    const b = step * Math.round((p * (r1 - r0)) / step) + r0;\n\n    return clamp(b, r0 < r1 ? r0 : r1, r1 > r0 ? r1 : r0);\n  };\n}\n","import React, { PureComponent, isValidElement } from 'react';\nimport warning from 'warning';\nimport { mode1, mode2, mode3 } from './modes';\nimport {\n  isNotValidTouch,\n  getTouchPosition,\n  getUpdatedHandles,\n  getSliderDomain,\n  getHandles,\n  prfx,\n} from './utils';\nimport { Rail } from '../Rail';\nimport { Handles } from '../Handles';\nimport { Ticks } from '../Ticks';\nimport { Tracks } from '../Tracks';\nimport { LinearScale } from '../scales/LinearScale';\nimport { DiscreteScale } from '../scales/DiscreteScale';\n\nimport { SliderProps, SliderState } from './types';\nimport { HandleItem } from '../types';\n\nconst isBrowser =\n  typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst noop = () => {};\n\nconst compare = (b: any[]) => (m: any, d: any, i: number) => m && b[i] === d;\n\nconst equal = (a: any, b: any) => {\n  return a === b || (a.length === b.length && a.reduce(compare(b), true));\n};\n\ninterface RCSComponent {\n  type: {\n    name: 'Rail' | 'Handles' | 'Ticks' | 'Tracks';\n  };\n}\n\nconst isRCSComponent = (item: React.ReactNode): item is RCSComponent => {\n  if (!isValidElement(item)) {\n    return false;\n  }\n\n  const type = (item as RCSComponent).type;\n  const name = type ? type.name : '';\n\n  return (\n    name === Handles.name ||\n    name === Rail.name ||\n    name === Ticks.name ||\n    name === Tracks.name\n  );\n};\n\nconst getNextValue = (\n  curr: number,\n  step: number,\n  domain: ReadonlyArray<number>,\n  reversed: boolean\n) => {\n  const newVal = reversed ? curr - step : curr + step;\n  return reversed ? Math.max(domain[0], newVal) : Math.min(domain[1], newVal);\n};\n\nconst getPrevValue = (\n  curr: number,\n  step: number,\n  domain: ReadonlyArray<number>,\n  reversed: boolean\n) => {\n  const newVal = reversed ? curr + step : curr - step;\n  return reversed ? Math.min(domain[1], newVal) : Math.max(domain[0], newVal);\n};\n\nconst defaultDomain = [0, 100];\n\nexport class Slider<\n  T extends HTMLDivElement = HTMLDivElement\n> extends PureComponent<SliderProps, SliderState> {\n  state = {\n    step: 0.1,\n    values: [],\n    domain: defaultDomain,\n    handles: [] as HandleItem[],\n    reversed: false,\n    activeHandleID: '',\n    valueToPerc: null,\n    valueToStep: null,\n    pixelToStep: null,\n  };\n\n  slider = React.createRef<T>();\n\n  static getDerivedStateFromProps(\n    nextProps: SliderProps,\n    prevState: SliderState\n  ) {\n    const {\n      step = 0.1,\n      values,\n      domain = defaultDomain,\n      reversed = false,\n      onUpdate = noop,\n      onChange = noop,\n      warnOnChanges = false,\n    } = nextProps;\n    let valueToPerc = prevState.valueToPerc;\n    let valueToStep = prevState.valueToStep;\n    let pixelToStep = prevState.pixelToStep;\n\n    const nextState: Partial<SliderState> = {};\n\n    if (!valueToPerc || !valueToStep || !pixelToStep) {\n      valueToPerc = new LinearScale();\n      valueToStep = new DiscreteScale();\n      pixelToStep = new DiscreteScale();\n\n      nextState.valueToPerc = valueToPerc;\n      nextState.valueToStep = valueToStep;\n      nextState.pixelToStep = pixelToStep;\n    }\n\n    if (\n      prevState.domain === defaultDomain ||\n      prevState.step === null ||\n      prevState.domain === null ||\n      prevState.reversed === null ||\n      step !== prevState.step ||\n      domain[0] !== prevState.domain[0] ||\n      domain[1] !== prevState.domain[1] ||\n      reversed !== prevState.reversed\n    ) {\n      const [min, max] = domain;\n      valueToStep.setStep(step).setRange([min, max]).setDomain([min, max]);\n\n      if (reversed === true) {\n        valueToPerc.setDomain([min, max]).setRange([100, 0]);\n        pixelToStep.setStep(step).setRange([max, min]);\n      } else {\n        valueToPerc.setDomain([min, max]).setRange([0, 100]);\n        pixelToStep.setStep(step).setRange([min, max]);\n      }\n\n      warning(\n        max > min,\n        `${prfx} Max must be greater than min (even if reversed). Max is ${max}. Min is ${min}.`\n      );\n\n      const { handles, changes } = getHandles(\n        values || prevState.values,\n        reversed,\n        valueToStep,\n        warnOnChanges\n      );\n\n      if (changes || values === undefined || values === prevState.values) {\n        onUpdate(handles.map((d) => d.val));\n        onChange(handles.map((d) => d.val));\n      }\n\n      nextState.step = step;\n      nextState.values = values;\n      nextState.domain = domain === defaultDomain ? [...domain] : domain;\n      nextState.handles = handles;\n      nextState.reversed = reversed;\n    } else if (!equal(values, prevState.values)) {\n      const { handles, changes } = getHandles(\n        values,\n        reversed,\n        valueToStep,\n        warnOnChanges\n      );\n\n      if (changes) {\n        onUpdate(handles.map((d) => d.val));\n        onChange(handles.map((d) => d.val));\n      }\n\n      nextState.values = values;\n      nextState.handles = handles;\n    }\n\n    if (Object.keys(nextState).length) {\n      return nextState;\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    const { pixelToStep } = this.state;\n    const { vertical } = this.props;\n\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n  }\n\n  componentWillUnmount() {\n    this.removeListeners();\n  }\n\n  removeListeners() {\n    if (isBrowser) {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUp);\n      document.removeEventListener('touchmove', this.onTouchMove);\n      document.removeEventListener('touchend', this.onTouchEnd);\n    }\n  }\n\n  onKeyDown = (e: KeyboardEvent, handleID: string) => {\n    let validUpKeys = ['ArrowRight', 'ArrowUp'];\n    let validDownKeys = ['ArrowDown', 'ArrowLeft'];\n\n    const {\n      state: { handles },\n      props: {\n        step = 0.1,\n        reversed = false,\n        vertical = false,\n        domain = [0, 100] as number[],\n      },\n    } = this;\n    const key = e.key || `${e.keyCode}`;\n\n    if (!validUpKeys.concat(validDownKeys).includes(key)) {\n      return;\n    }\n\n    if (vertical) {\n      [validUpKeys, validDownKeys] = [validDownKeys, validUpKeys];\n    }\n\n    e.stopPropagation && e.stopPropagation();\n    e.preventDefault && e.preventDefault();\n\n    const found = handles.find((value) => {\n      return value.key === handleID;\n    });\n\n    if (!found) {\n      return;\n    }\n\n    const currVal = found.val;\n    let newVal = currVal;\n\n    if (validUpKeys.includes(key)) {\n      newVal = getNextValue(currVal, step, domain, reversed);\n    } else if (validDownKeys.includes(key)) {\n      newVal = getPrevValue(currVal, step, domain, reversed);\n    }\n    const nextHandles = handles.map((v) =>\n      v.key === handleID ? { key: v.key, val: newVal } : v\n    );\n\n    this.submitUpdate(nextHandles, true);\n  };\n\n  onMouseDown = (e: MouseEvent, handleID: string) => {\n    this.onStart(e, handleID, false);\n  };\n\n  onTouchStart = (e: TouchEvent, handleID: string) => {\n    if (isNotValidTouch(e)) {\n      return;\n    }\n\n    this.onStart(e, handleID, true);\n  };\n\n  onStart(e: MouseEvent | TouchEvent, handleID: string, isTouch: boolean) {\n    const {\n      state: { handles },\n      props: { onSlideStart = noop },\n    } = this;\n\n    if (!isTouch) {\n      e.preventDefault && e.preventDefault();\n    }\n\n    e.stopPropagation && e.stopPropagation();\n\n    const found = handles.find((value) => {\n      return value.key === handleID;\n    });\n\n    if (found) {\n      this.setState({ activeHandleID: handleID });\n      onSlideStart(\n        handles.map((d) => d.val),\n        { activeHandleID: handleID }\n      );\n      isTouch ? this.addTouchEvents() : this.addMouseEvents();\n    } else {\n      this.setState({ activeHandleID: '' });\n      this.handleRailAndTrackClicks(e, isTouch);\n    }\n  }\n\n  handleRailAndTrackClicks(e: MouseEvent | TouchEvent, isTouch: boolean) {\n    const {\n      state: { handles: curr, pixelToStep },\n      props: { vertical, reversed = false },\n    } = this;\n    const { slider } = this;\n\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(slider.current, vertical));\n\n    // find the closest value (aka step) to the event location\n    let updateValue: number;\n\n    if (isTouch) {\n      // @ts-ignore\n      updateValue = pixelToStep.getValue(getTouchPosition(vertical, e));\n    } else {\n      // @ts-ignore\n      updateValue = pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n    }\n\n    // find the closest handle key\n    let updateKey = '';\n    let minDiff = Infinity;\n\n    for (let i = 0; i < curr.length; i++) {\n      const { key, val } = curr[i];\n      const diff = Math.abs(val - updateValue);\n\n      if (diff < minDiff) {\n        updateKey = key;\n        minDiff = diff;\n      }\n    }\n\n    // generate a \"candidate\" set of values - a suggestion of what to do\n    const nextHandles = getUpdatedHandles(\n      curr,\n      updateKey,\n      updateValue,\n      reversed\n    );\n\n    // submit the candidate values\n    this.setState({ activeHandleID: updateKey }, () => {\n      this.submitUpdate(nextHandles, true);\n      isTouch ? this.addTouchEvents() : this.addMouseEvents();\n    });\n  }\n\n  getEventData = (e: React.MouseEvent | React.TouchEvent, isTouch: boolean) => {\n    const {\n      state: { pixelToStep, valueToPerc },\n      props: { vertical },\n    } = this;\n\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n\n    let value;\n\n    if (isTouch && e instanceof TouchEvent) {\n      // @ts-ignore\n      value = pixelToStep.getValue(getTouchPosition(vertical, e));\n    } else if (e instanceof MouseEvent) {\n      // @ts-ignore\n      value = pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n    }\n    return {\n      value,\n      // @ts-ignore\n      percent: valueToPerc.getValue(value),\n    };\n  };\n\n  addMouseEvents() {\n    if (isBrowser) {\n      document.addEventListener('mousemove', this.onMouseMove);\n      document.addEventListener('mouseup', this.onMouseUp);\n    }\n  }\n\n  addTouchEvents() {\n    if (isBrowser) {\n      document.addEventListener('touchmove', this.onTouchMove);\n      document.addEventListener('touchend', this.onTouchEnd);\n    }\n  }\n\n  onMouseMove = (e: MouseEvent) => {\n    const {\n      state: { handles: curr, pixelToStep, activeHandleID = '' },\n      props: { vertical, reversed = false },\n    } = this;\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n\n    // find the closest value (aka step) to the event location\n    // @ts-ignore\n    const updateValue = pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n\n    // generate a \"candidate\" set of values - a suggestion of what to do\n    const nextHandles = getUpdatedHandles(\n      curr,\n      activeHandleID,\n      updateValue,\n      reversed\n    );\n\n    // submit the candidate values\n    this.submitUpdate(nextHandles);\n  };\n\n  onTouchMove = (e: TouchEvent) => {\n    const {\n      state: { handles: curr, pixelToStep, activeHandleID },\n      props: { vertical, reversed },\n    } = this;\n    if (pixelToStep === null || isNotValidTouch(e)) {\n      return;\n    }\n\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n\n    // find the closest value (aka step) to the event location\n    // @ts-ignore\n    const updateValue = pixelToStep.getValue(getTouchPosition(vertical, e));\n\n    // generate a \"candidate\" set of values - a suggestion of what to do\n    const nextHandles = getUpdatedHandles(\n      curr,\n      activeHandleID,\n      updateValue,\n      reversed\n    );\n\n    // submit the candidate values\n    this.submitUpdate(nextHandles);\n  };\n\n  submitUpdate(next: HandleItem[], callOnChange = false) {\n    const {\n      mode = 1,\n      step = 0.1,\n      onUpdate = noop,\n      onChange = noop,\n      reversed = false,\n    } = this.props;\n    //@ts-ignore\n    const { getValue } = this.state.valueToStep;\n\n    this.setState(({ handles: curr }) => {\n      let handles: HandleItem[] = [];\n\n      // given the current handles and a candidate set, decide what to do\n      if (typeof mode === 'function') {\n        handles = mode(curr, next, step, reversed, getValue);\n        warning(\n          Array.isArray(handles),\n          'Custom mode function did not return an array.'\n        );\n      } else {\n        switch (mode) {\n          case 1:\n            handles = mode1(curr, next);\n            break;\n          case 2:\n            handles = mode2(curr, next);\n            break;\n          case 3:\n            handles = mode3(curr, next, step, reversed, getValue);\n            break;\n          default:\n            handles = next;\n            warning(false, `${prfx} Invalid mode value.`);\n        }\n      }\n\n      onUpdate(handles.map((d) => d.val));\n\n      if (callOnChange) {\n        onChange(handles.map((d) => d.val));\n      }\n\n      return { handles };\n    });\n  }\n\n  onMouseUp = () => {\n    const {\n      state: { handles = [], activeHandleID },\n      props: { onChange = noop, onSlideEnd = noop },\n    } = this;\n\n    onChange(handles.map((d) => d.val));\n    onSlideEnd(\n      handles.map((d) => d.val),\n      { activeHandleID }\n    );\n\n    this.setState({ activeHandleID: '' });\n\n    if (isBrowser) {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUp);\n    }\n  };\n\n  onTouchEnd = () => {\n    const {\n      state: { handles, activeHandleID },\n      props: { onChange = noop, onSlideEnd = noop },\n    } = this;\n\n    onChange(handles.map((d) => d.val));\n    onSlideEnd(\n      handles.map((d) => d.val),\n      { activeHandleID }\n    );\n\n    this.setState({ activeHandleID: '' });\n\n    if (isBrowser) {\n      document.removeEventListener('touchmove', this.onTouchMove);\n      document.removeEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  render() {\n    const {\n      state: { handles, valueToPerc, activeHandleID },\n      props: {\n        className,\n        rootStyle = {},\n        rootProps = {},\n        component: Comp = 'div',\n        disabled = false,\n        flatten = false,\n      },\n    } = this;\n\n    const mappedHandles = handles.map(({ key, val }) => {\n      // @ts-ignore\n      return { id: key, value: val, percent: valueToPerc.getValue(val) };\n    });\n\n    const children = React.Children.map(this.props.children, (child) => {\n      if (isRCSComponent(child) === true) {\n        return React.cloneElement(child as React.ReactElement, {\n          scale: valueToPerc,\n          handles: mappedHandles,\n          activeHandleID,\n          getEventData: this.getEventData,\n          emitKeyboard: disabled ? noop : this.onKeyDown,\n          emitMouse: disabled ? noop : this.onMouseDown,\n          emitTouch: disabled ? noop : this.onTouchStart,\n        });\n      } else {\n        return child;\n      }\n    });\n\n    return flatten ? (\n      <>\n        {React.createElement(Comp, {\n          ...rootProps,\n          style: rootStyle,\n          className: className,\n          ref: this.slider,\n        })}\n        {children}\n      </>\n    ) : (\n      <>\n        {React.createElement(\n          Comp,\n          {\n            ...rootProps,\n            style: rootStyle,\n            className: className,\n            ref: this.slider,\n          },\n          children\n        )}\n      </>\n    );\n  }\n}\n"],"sourceRoot":""}